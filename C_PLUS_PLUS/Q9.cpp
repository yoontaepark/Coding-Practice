// C++ Coding test 
// Question 9) 모두의 약수: 자연수 N이 입력되면 1부터 N까지의 각 숫자들의 약수의 개수를 출력하는 프로그램을 작성하세요. 
// 만약 N이 8이 입력된다면 1(1개), 2(2개), 3(2개), 4(3개), 5(2개), 6(4개), 7(2개), 8(4개)와 같이 각 숫자의 약수의 개수가 구해짐
// 출력은 다음과 같이 1부터 차례대로 약수의 개수만 출력하면 됨
// 1 2 2 3 2 4 2 4 와 같이 출력한다. 
// 복잡도가 n^2보다 낮아야 한다.

// 입력설명: 첫 번째 줄에 자연수 N(5<=N<=50,000)가 주어진다.
// 출력설명: 첫 번째 줄에 1부터 N까지 약수의 개수를 순서대로 출력한다. 

// 입력예제: 8
// 출력예제: 1 2 2 3 2 4 2 4


// 방법1: 흔히 할법한 n^2 로직, 시간복잡도때문에 더 효율적으로 짜는게 필요
//#include <stdio.h>
//using namespace std;
//
//int main()
//{
//	int i, j, a = 0, cnt=0;
//
//	freopen("input.txt", "rt", stdin);
//	scanf("%d", &a);
//
//	for (i = 1; i <= a; i++)
//	{
//		cnt = 0;
//		for (j = 1; j <= i; j++)
//		{
//			if (i % j == 0)
//				cnt++;
//		}
//		printf("%d ", cnt);
//	}
//
//	return 0;
//}

//방법2: cnt[50001] = {0, 0, 0, 0, 0, 0, ...,0} 으로 두고 약수를 하나씩 올리면서 각 숫자에 들어갈지 일괄로 확인 및 + 해준다
//즉 배수단위로 모두의 약수인지를 확인한다. 

#include <stdio.h>
using namespace std;

int main()
{
	//freopen("input.txt", "rt", stdin);

	// 배열을 만들어서 일단 다 0으로 깔아두기
	int cnt[50001] = { 0 };
	int i, j, n;

	scanf("%d", &n);

	// i=1에서부터 n까지 하는건 맞는데
	for (i = 1; i <= n; i++)
	{
		// j=1일때는 1~n까지 1의배수만큼 올려보고, j=2일때는 2~n까지 2의배수만큼 돌려보고,...
		for (j = i; j <= n; j = j + i)
		{
			cnt[j]++;
		}
	}

	// cnt 배열에 차있는 값들을 수확하기만 하면 됨 
	for (i = 1; i <= n; i++)
		printf("%d ", cnt[i]);


	return 0;
}