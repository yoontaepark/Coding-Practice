# 문제: 위상정렬(백준 1766번)
# 한줄 풀이: 위상 정렬, 순서가 정해져 있는 작업을 차례로 수행해야 할 때, 순서를 결정해주는 알고리즘 (시간복잡도: V + E)
# 위상 정렬 알고리즘: 진입 차수가 0인 정점을 큐에 삽입 -> 큐에서 원소를 꺼내 해당 원소와 간선을 제거 -> 제거 후 진입차수가 0인 정점을 큐에 삽입 -> 큐가 빌떄까지 반복


# 민오는 1번부터 N번까지 총 N개의 문제로 되어 있는 문제집을 풀려고 한다. 문제는 난이도 순서로 출제되어 있다. 즉 1번 문제가 가장 쉬운 문제이고 N번 문제가 가장 어려운 문제가 된다.

# 어떤 문제부터 풀까 고민하면서 문제를 훑어보던 민오는, 몇몇 문제들 사이에는 '먼저 푸는 것이 좋은 문제'가 있다는 것을 알게 되었다. 
# 예를 들어 1번 문제를 풀고 나면 4번 문제가 쉽게 풀린다거나 하는 식이다. 민오는 다음의 세 가지 조건에 따라 문제를 풀 순서를 정하기로 하였다.

# N개의 문제는 모두 풀어야 한다.
# 먼저 푸는 것이 좋은 문제가 있는 문제는, 먼저 푸는 것이 좋은 문제를 반드시 먼저 풀어야 한다.
# 가능하면 쉬운 문제부터 풀어야 한다.
# 예를 들어서 네 개의 문제가 있다고 하자. 4번 문제는 2번 문제보다 먼저 푸는 것이 좋고, 3번 문제는 1번 문제보다 먼저 푸는 것이 좋다고 하자. 
# 만일 4-3-2-1의 순서로 문제를 풀게 되면 조건 1과 조건 2를 만족한다. 하지만 조건 3을 만족하지 않는다. 4보다 3을 충분히 먼저 풀 수 있기 때문이다. 
# 따라서 조건 3을 만족하는 문제를 풀 순서는 3-1-4-2가 된다.

# 문제의 개수와 먼저 푸는 것이 좋은 문제에 대한 정보가 주어졌을 때, 주어진 조건을 만족하면서 민오가 풀 문제의 순서를 결정해 주는 프로그램을 작성하시오.

# 입력
# 첫째 줄에 문제의 수 N(1 ≤ N ≤ 32,000)과 먼저 푸는 것이 좋은 문제에 대한 정보의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 
# 둘째 줄부터 M개의 줄에 걸쳐 두 정수의 순서쌍 A,B가 빈칸을 사이에 두고 주어진다. 이는 A번 문제는 B번 문제보다 먼저 푸는 것이 좋다는 의미이다.
# 항상 문제를 모두 풀 수 있는 경우만 입력으로 주어진다.

# 출력
# 첫째 줄에 문제 번호를 나타내는 1 이상 N 이하의 정수들을 민오가 풀어야 하는 순서대로 빈칸을 사이에 두고 출력한다.

# 예제 입력 1 
# 4 2
# 4 2
# 3 1
# 예제 출력 1 
# 3 1 4 2

import heapq
n, m = map(int, input().split())
array = [[] for i in range(n+1)] # 배열을 만들어놓는데, 편의상 0번 인덱스를 안쓰려고 n+1 개를 만든 모습
indegree = [0] * (n+1) # 해당노드로의 진입차수를 0으로 초기화 

heap = []
result = []

# m번 반복하면서 (4,2)면 4번 인덱스에 2를 넣는다. 4-> 2 라는 뜻, 그리고 2번 인덱스에는 진입차수를 1 더해준다
for _ in range(m):
    x, y = map(int, input().split())
    array[x].append(y)
    indegree[y] += 1

# 진입차수가 0인 인덱스번호를 힙에 넣는다
for i in range(1, n+1):
    if indegree[i] == 0:
        heapq.heappush(heap, i)


while heap:
    # 힙에 있는걸 하나씩 빼면서
    data = heapq.heappop(heap)
    # 뺀건 결과값에 넣고
    result.append(data)
    # 뺀 값에 해당하는 인덱스를 뒤져서, 연결되어 있는 후속 인덱스의 진입차수를 1 빼준다
    for y in array[data]:
        indegree[y] -= 1
        # 그러고나서 진입차수가 0이라면 우선적으로 힙에 다시 넣는다. 
        if indegree[y] == 0:
            heapq.heappush(heap,y)
    
for i in result:
    print(i, end=' ')
